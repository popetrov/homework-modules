/**
 * Based on http://www.passwordmeter.com/ created by Jeff Todnem
 *
 * Created by: Stephan Schmitz <eyecatchup@gmail.com>
 * Created on: 2019-05-02
 *
 * License Information:
 * -------------------------------------------------------------------------
 *
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 **/

let passwordMeter = {};

passwordMeter.check = (str) => {
  const stringReverse = (str) => {
    return str.split('').reverse().join('');
  }

  let nScore = 0,
    nLength = 0,
    nAlphaUC = 0,
    nAlphaLC = 0,
    nNumber = 0,
    nSymbol = 0,
    nMidChar = 0,
    nRequirements = 0,
    nAlphasOnly = 0,
    nNumbersOnly = 0,
    nUnqChar = 0,
    nRepChar = 0,
    nRepInc = 0,
    nConsecAlphaUC = 0,
    nConsecAlphaLC = 0,
    nConsecNumber = 0,
    nConsecSymbol = 0,
    nConsecCharType = 0,
    nSeqAlpha = 0,
    nSeqNumber = 0,
    nSeqSymbol = 0,
    nSeqChar = 0;
  let nMultMidChar = 2,
    nMultConsecAlphaUC = 2,
    nMultConsecAlphaLC = 2,
    nMultConsecNumber = 2;
  let nMultSeqAlpha = 3,
    nMultSeqNumber = 3,
    nMultSeqSymbol = 3;
  let nMultLength = 4,
    nMultNumber = 4;
  let nMultSymbol = 6;
  let nTmpAlphaUC = "",
    nTmpAlphaLC = "",
    nTmpNumber = "",
    nTmpSymbol = "";
  let sLength = 0,
    sAlphaUC = 0,
    sAlphaLC = 0,
    sNumber = 0,
    sSymbol = 0,
    sMidChar = 0,
    sRequirements = 0,
    sAlphasOnly = 0,
    sNumbersOnly = 0,
    sRepChar = 0,
    sConsecAlphaUC = 0,
    sConsecAlphaLC = 0,
    sConsecNumber = 0,
    sSeqAlpha = 0,
    sSeqNumber = 0,
    sSeqSymbol = 0;
  let sAlphas = "abcdefghijklmnopqrstuvwxyz";
  let sNumerics = "01234567890";
  let sSymbols = "!\"#$%&'()*+,-./:;<=>?[\\]^`{|}~";
  let sComplexity = 1;
  let nMinPwdLen = 8; //Mindestens 8 Zeichen

  if (str) {
    nScore = parseInt(str.length * nMultLength);
    nLength = str.length;
    let arrPwd = str.replace(/\s+/g, "").split(/\s*/);
    let arrPwdLen = arrPwd.length;

    /* Loop through password to check for Symbol, Numeric, Lowercase and Uppercase pattern matches */
    for (let a = 0; a < arrPwdLen; a++) {
      if (arrPwd[a].match(/[A-Z]/g)) {
        if (nTmpAlphaUC !== "") {
          if ((nTmpAlphaUC + 1) === a) {
            nConsecAlphaUC++;
            nConsecCharType++;
          }
        }
        nTmpAlphaUC = a;
        nAlphaUC++;
      } else if (arrPwd[a].match(/[a-z]/g)) {
        if (nTmpAlphaLC !== "") {
          if ((nTmpAlphaLC + 1) === a) {
            nConsecAlphaLC++;
            nConsecCharType++;
          }
        }
        nTmpAlphaLC = a;
        nAlphaLC++;
      } else if (arrPwd[a].match(/[0-9]/g)) {
        if (a > 0 && a < (arrPwdLen - 1)) {
          nMidChar++;
        }
        if (nTmpNumber !== "") {
          if ((nTmpNumber + 1) === a) {
            nConsecNumber++;
            nConsecCharType++;
          }
        }
        nTmpNumber = a;
        nNumber++;
      } else if (arrPwd[a].match(/[^a-zA-Z0-9_]/g)) {
        if (a > 0 && a < (arrPwdLen - 1)) {
          nMidChar++;
        }
        if (nTmpSymbol !== "") {
          if ((nTmpSymbol + 1) === a) {
            nConsecSymbol++;
            nConsecCharType++;
          }
        }
        nTmpSymbol = a;
        nSymbol++;
      }
      /* Internal loop through password to check for repeat characters */
      let bCharExists = false;
      for (let b = 0; b < arrPwdLen; b++) {
        if (arrPwd[a] === arrPwd[b] && a !== b) {
          /* repeat character exists */
          bCharExists = true;
          /*
           Calculate increment deduction based on proximity to identical characters
           Deduction is incremented each time a new match is discovered
           Deduction amount is based on total password length divided by the
           difference of distance between currently selected match
           */
          nRepInc += Math.abs(arrPwdLen / (b - a));
        }
      }
      if (bCharExists) {
        nRepChar++;
        nUnqChar = arrPwdLen - nRepChar;
        nRepInc = (nUnqChar) ? Math.ceil(nRepInc / nUnqChar) : Math.ceil(nRepInc);
      }
    }

    /* Check for sequential alpha string patterns (forward and reverse) */
    let s, sFwd, sRev;
    for (s = 0; s < 23; s++) {
      sFwd = sAlphas.substring(s, parseInt(s + 3));
      sRev = stringReverse(sFwd);
      if (str.toLowerCase().indexOf(sFwd) !== -1 || str.toLowerCase().indexOf(sRev) !== -1) {
        nSeqAlpha++;
        nSeqChar++;
      }
    }

    /* Check for sequential numeric string patterns (forward and reverse) */
    for (s = 0; s < 8; s++) {
      sFwd = sNumerics.substring(s, parseInt(s + 3));
      sRev = stringReverse(sFwd);
      if (str.toLowerCase().indexOf(sFwd) !== -1 || str.toLowerCase().indexOf(sRev) !== -1) {
        nSeqNumber++;
        nSeqChar++;
      }
    }

    /* Check for sequential symbol string patterns (forward and reverse) */
    for (s = 0; s < 8; s++) {
      sFwd = sSymbols.substring(s, parseInt(s + 3));
      sRev = stringReverse(sFwd);
      if (str.toLowerCase().indexOf(sFwd) !== -1 || str.toLowerCase().indexOf(sRev) !== -1) {
        nSeqSymbol++;
        nSeqChar++;
      }
    }

    /* Modify overall score value based on usage vs requirements */

    /*
     * General point assignment
     */
    sLength = nScore;
    if (nAlphaUC > 0 && nAlphaUC < nLength) {
      nScore = parseInt(nScore + ((nLength - nAlphaUC) * 2));
      sAlphaUC = parseInt((nLength - nAlphaUC) * 2);
    }
    if (nAlphaLC > 0 && nAlphaLC < nLength) {
      nScore = parseInt(nScore + ((nLength - nAlphaLC) * 2));
      sAlphaLC = parseInt((nLength - nAlphaLC) * 2);
    }
    if (nNumber > 0 && nNumber < nLength) {
      nScore = parseInt(nScore + (nNumber * nMultNumber));
      sNumber = parseInt(nNumber * nMultNumber);
    }
    if (nSymbol > 0) {
      nScore = parseInt(nScore + (nSymbol * nMultSymbol));
      sSymbol = parseInt(nSymbol * nMultSymbol);
    }
    if (nMidChar > 0) {
      nScore = parseInt(nScore + (nMidChar * nMultMidChar));
      sMidChar = parseInt(nMidChar * nMultMidChar);
    }


    /*
     * Point deductions for poor practices
     */
    if ((nAlphaLC > 0 || nAlphaUC > 0) && nSymbol === 0 && nNumber === 0) { // Only Letters
      nScore = parseInt(nScore - nLength);
      nAlphasOnly = nLength;
      sAlphasOnly = -nLength;
    }
    if (nAlphaLC === 0 && nAlphaUC === 0 && nSymbol === 0 && nNumber > 0) { // Only Numbers
      nScore = parseInt(nScore - nLength);
      nNumbersOnly = nLength;
      sNumbersOnly = -nLength;
    }
    if (nRepChar > 0) { // Same character exists more than once
      nScore = parseInt(nScore - nRepInc);
      sRepChar = -nRepInc;
    }
    if (nConsecAlphaUC > 0) { // Consecutive Uppercase Letters exist
      nScore = parseInt(nScore - (nConsecAlphaUC * nMultConsecAlphaUC));
      sConsecAlphaUC = -parseInt(nConsecAlphaUC * nMultConsecAlphaUC);
    }
    if (nConsecAlphaLC > 0) { // Consecutive Lowercase Letters exist
      nScore = parseInt(nScore - (nConsecAlphaLC * nMultConsecAlphaLC));
      sConsecAlphaLC = -parseInt(nConsecAlphaLC * nMultConsecAlphaLC);
    }
    if (nConsecNumber > 0) { // Consecutive Numbers exist
      nScore = parseInt(nScore - (nConsecNumber * nMultConsecNumber));
      sConsecNumber = -parseInt(nConsecNumber * nMultConsecNumber);
    }
    if (nSeqAlpha > 0) { // Sequential alpha strings exist (3 characters or more)
      nScore = parseInt(nScore - (nSeqAlpha * nMultSeqAlpha));
      sSeqAlpha = -parseInt(nSeqAlpha * nMultSeqAlpha);
    }
    if (nSeqNumber > 0) { // Sequential numeric strings exist (3 characters or more)
      nScore = parseInt(nScore - (nSeqNumber * nMultSeqNumber));
      sSeqNumber = -parseInt(nSeqNumber * nMultSeqNumber);
    }
    if (nSeqSymbol > 0) { // Sequential symbol strings exist (3 characters or more)
      nScore = parseInt(nScore - (nSeqSymbol * nMultSeqSymbol));
      sSeqSymbol = -parseInt(nSeqSymbol * nMultSeqSymbol);
    }


    /*
     * Determine if mandatory requirements have been met and if additional bonuses need to be applied
     */
    let arrChars = [nLength, nAlphaUC, nAlphaLC, nNumber, nSymbol];
    let arrCharsIds = ["nLength", "nAlphaUC", "nAlphaLC", "nNumber", "nSymbol"];
    let arrCharsLen = arrChars.length;
    let nReqChar = 0;
    let minVal;
    for (let c = 0; c < arrCharsLen; c++) {
      if (arrCharsIds[c] === "nLength") {
        minVal = parseInt(nMinPwdLen - 1);
      } else {
        minVal = 0;
      }
      if (arrChars[c] === parseInt(minVal + 1)) {
        nReqChar++;
      } else if (arrChars[c] > parseInt(minVal + 1)) {
        nReqChar++;
      }
    }
    nRequirements = nReqChar;
    let nMinReqChars;
    if (str.length >= nMinPwdLen) {
      nMinReqChars = 3;
    } else {
      nMinReqChars = 4;
    }
    if (nRequirements > nMinReqChars) { // One or more required characters exist
      nScore = parseInt(nScore + (nRequirements * 2));
      sRequirements = parseInt(nRequirements * 2);
    }

    /*
     * Determine complexity based on overall score
     */
    if (nScore > 100) {
      nScore = 100;
    } else if (nScore < 0) {
      nScore = 0;
    }
    if (nScore >= 0 && nScore < 20) {
      sComplexity = 1;
    } else if (nScore >= 20 && nScore < 40) {
      sComplexity = 2;
    } else if (nScore >= 40 && nScore < 60) {
      sComplexity = 3;
    } else if (nScore >= 60 && nScore < 80) {
      sComplexity = 4;
    } else if (nScore >= 80 && nScore <= 100) {
      sComplexity = 5;
    }

    return {
      score: nScore, //0-100
      complexity: sComplexity, //1-5
      additions: {
        numberOfCharacters: {
          count: nLength,
          bonus: sLength
        },
        uppercaseLetters: {
          count: nAlphaUC,
          bonus: sAlphaUC
        },
        lowercaseLetters: {
          count: nAlphaLC,
          bonus: sAlphaLC
        },
        numbers: {
          count: nNumber,
          bonus: sNumber
        },
        symbols: {
          count: nSymbol,
          bonus: sSymbol
        },
        middleNumbersOrSymbols: {
          count: nMidChar,
          bonus: sMidChar
        },
        requirements: {
          count: nRequirements,
          bonus: sRequirements
        }
      },
      deductions: {
        lettersOnly: {
          count: nAlphasOnly,
          bonus: sAlphasOnly
        },
        numbersOnly: {
          count: nNumbersOnly,
          bonus: sNumbersOnly
        },
        repeatCharacters: {
          count: nRepChar,
          bonus: sRepChar
        },
        consecutiveUppercaseLetters: {
          count: nConsecAlphaUC,
          bonus: sConsecAlphaUC
        },
        consecutiveLowercaseLetters: {
          count: nConsecAlphaLC,
          bonus: sConsecAlphaLC
        },
        consecutiveNumbers: {
          count: nConsecNumber,
          bonus: sConsecNumber
        },
        sequentialLetters: {
          count: nSeqAlpha,
          bonus: sSeqAlpha
        },
        sequentialNumbers: {
          count: nSeqNumber,
          bonus: sSeqNumber
        },
        sequentialSymbols: {
          count: nSeqSymbol,
          bonus: sSeqSymbol
        }
      }
    };
  } else {
    return false;
  }
}


